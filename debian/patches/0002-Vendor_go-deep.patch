Description: Vendor_go deep
 Copyright: 2015-2017 Daniel Nichter
 License: MIT
 Commit: f49763a6ea0a91026be26f8213bebee726b4185f
 Retrieved from: https://github.com/go-test/deep
 .
 github.com/go-test/deep library.
--- a/ex_test.go
+++ b/ex_test.go
@@ -8,7 +8,7 @@
 	"os"
 	"testing"
 
-	"github.com/go-test/deep"
+	"github.com/google/mtail/deep"
 	"github.com/google/mtail/metrics"
 	"github.com/google/mtail/mtail"
 	"github.com/google/mtail/testdata"
--- /dev/null
+++ b/deep/deep.go
@@ -0,0 +1,345 @@
+// Package deep provides function deep.Equal which is like reflect.DeepEqual but
+// returns a list of differences. This is helpful when comparing complex types
+// like structures and maps.
+package deep
+
+import (
+	"errors"
+	"fmt"
+	"log"
+	"reflect"
+	"strings"
+)
+
+var (
+	// FloatPrecision is the number of decimal places to round float values
+	// to when comparing.
+	FloatPrecision = 10
+
+	// MaxDiff specifies the maximum number of differences to return.
+	MaxDiff = 10
+
+	// MaxDepth specifies the maximum levels of a struct to recurse into.
+	MaxDepth = 10
+
+	// LogErrors causes errors to be logged to STDERR when true.
+	LogErrors = false
+
+	// CompareUnexportedFields causes unexported struct fields, like s in
+	// T{s int}, to be comparsed when true.
+	CompareUnexportedFields = false
+)
+
+var (
+	// ErrMaxRecursion is logged when MaxDepth is reached.
+	ErrMaxRecursion = errors.New("recursed to MaxDepth")
+
+	// ErrTypeMismatch is logged when Equal passed two different types of values.
+	ErrTypeMismatch = errors.New("variables are different reflect.Type")
+
+	// ErrNotHandled is logged when a primitive Go kind is not handled.
+	ErrNotHandled = errors.New("cannot compare the reflect.Kind")
+)
+
+type cmp struct {
+	diff        []string
+	buff        []string
+	floatFormat string
+}
+
+var errorType = reflect.TypeOf((*error)(nil)).Elem()
+
+// Equal compares variables a and b, recursing into their structure up to
+// MaxDepth levels deep, and returns a list of differences, or nil if there are
+// none. Some differences may not be found if an error is also returned.
+//
+// If a type has an Equal method, like time.Equal, it is called to check for
+// equality.
+func Equal(a, b interface{}) []string {
+	aVal := reflect.ValueOf(a)
+	bVal := reflect.ValueOf(b)
+	c := &cmp{
+		diff:        []string{},
+		buff:        []string{},
+		floatFormat: fmt.Sprintf("%%.%df", FloatPrecision),
+	}
+	if a == nil && b == nil {
+		return nil
+	} else if a == nil && b != nil {
+		c.saveDiff(b, "<nil pointer>")
+	} else if a != nil && b == nil {
+		c.saveDiff(a, "<nil pointer>")
+	}
+	if len(c.diff) > 0 {
+		return c.diff
+	}
+
+	c.equals(aVal, bVal, 0)
+	if len(c.diff) > 0 {
+		return c.diff // diffs
+	}
+	return nil // no diffs
+}
+
+func (c *cmp) equals(a, b reflect.Value, level int) {
+	if level > MaxDepth {
+		logError(ErrMaxRecursion)
+		return
+	}
+
+	// If differenet types, they can't be equal
+	aType := a.Type()
+	bType := b.Type()
+	if aType != bType {
+		c.saveDiff(aType, bType)
+		logError(ErrTypeMismatch)
+		return
+	}
+
+	// Primitive https://golang.org/pkg/reflect/#Kind
+	aKind := a.Kind()
+	bKind := b.Kind()
+
+	// If both types implement the error interface, compare the error strings.
+	// This must be done before dereferencing because the interface is on a
+	// pointer receiver.
+	if aType.Implements(errorType) && bType.Implements(errorType) {
+		if a.Elem().IsValid() && b.Elem().IsValid() { // both err != nil
+			aString := a.MethodByName("Error").Call(nil)[0].String()
+			bString := b.MethodByName("Error").Call(nil)[0].String()
+			if aString != bString {
+				c.saveDiff(aString, bString)
+			}
+			return
+		}
+	}
+
+	// Dereference pointers and interface{}
+	if aKind == reflect.Ptr || aKind == reflect.Interface {
+		a = a.Elem()
+		aKind = a.Kind()
+		if a.IsValid() {
+			aType = a.Type()
+		}
+	}
+	if bKind == reflect.Ptr || bKind == reflect.Interface {
+		b = b.Elem()
+		if b.IsValid() {
+			bType = b.Type()
+		}
+	}
+
+	// Check if one value is nil, e.g. T{x: *X} and T.x is nil
+	if !a.IsValid() || !b.IsValid() {
+		if a.IsValid() && !b.IsValid() {
+			c.saveDiff(aType, "<nil pointer>")
+		} else if !a.IsValid() && b.IsValid() {
+			c.saveDiff("<nil pointer>", bType)
+		}
+		return
+	}
+
+	// Types with an Equal(), like time.Time.
+	eqFunc := a.MethodByName("Equal")
+	if eqFunc.IsValid() {
+		retVals := eqFunc.Call([]reflect.Value{b})
+		if !retVals[0].Bool() {
+			c.saveDiff(a, b)
+		}
+		return
+	}
+
+	switch aKind {
+
+	/////////////////////////////////////////////////////////////////////
+	// Iterable kinds
+	/////////////////////////////////////////////////////////////////////
+
+	case reflect.Struct:
+		/*
+			The variables are structs like:
+				type T struct {
+					FirstName string
+					LastName  string
+				}
+			Type = <pkg>.T, Kind = reflect.Struct
+
+			Iterate through the fields (FirstName, LastName), recurse into their values.
+		*/
+		for i := 0; i < a.NumField(); i++ {
+			if aType.Field(i).PkgPath != "" && !CompareUnexportedFields {
+				continue // skip unexported field, e.g. s in type T struct {s string}
+			}
+
+			c.push(aType.Field(i).Name) // push field name to buff
+
+			// Get the Value for each field, e.g. FirstName has Type = string,
+			// Kind = reflect.String.
+			af := a.Field(i)
+			bf := b.Field(i)
+
+			// Recurse to compare the field values
+			c.equals(af, bf, level+1)
+
+			c.pop() // pop field name from buff
+
+			if len(c.diff) >= MaxDiff {
+				break
+			}
+		}
+	case reflect.Map:
+		/*
+			The variables are maps like:
+				map[string]int{
+					"foo": 1,
+					"bar": 2,
+				}
+			Type = map[string]int, Kind = reflect.Map
+
+			Or:
+				type T map[string]int{}
+			Type = <pkg>.T, Kind = reflect.Map
+
+			Iterate through the map keys (foo, bar), recurse into their values.
+		*/
+
+		if a.IsNil() || b.IsNil() {
+			if a.IsNil() && !b.IsNil() {
+				c.saveDiff("<nil map>", b)
+			} else if !a.IsNil() && b.IsNil() {
+				c.saveDiff(a, "<nil map>")
+			}
+			return
+		}
+
+		if a.Pointer() == b.Pointer() {
+			return
+		}
+
+		for _, key := range a.MapKeys() {
+			c.push(fmt.Sprintf("map[%s]", key))
+
+			aVal := a.MapIndex(key)
+			bVal := b.MapIndex(key)
+			if bVal.IsValid() {
+				c.equals(aVal, bVal, level+1)
+			} else {
+				c.saveDiff(aVal, "<does not have key>")
+			}
+
+			c.pop()
+
+			if len(c.diff) >= MaxDiff {
+				return
+			}
+		}
+
+		for _, key := range b.MapKeys() {
+			if aVal := a.MapIndex(key); aVal.IsValid() {
+				continue
+			}
+
+			c.push(fmt.Sprintf("map[%s]", key))
+			c.saveDiff("<does not have key>", b.MapIndex(key))
+			c.pop()
+			if len(c.diff) >= MaxDiff {
+				return
+			}
+		}
+	case reflect.Slice:
+		if a.IsNil() || b.IsNil() {
+			if a.IsNil() && !b.IsNil() {
+				c.saveDiff("<nil slice>", b)
+			} else if !a.IsNil() && b.IsNil() {
+				c.saveDiff(a, "<nil slice>")
+			}
+			return
+		}
+
+		if a.Pointer() == b.Pointer() {
+			return
+		}
+
+		aLen := a.Len()
+		bLen := b.Len()
+		n := aLen
+		if bLen > aLen {
+			n = bLen
+		}
+		for i := 0; i < n; i++ {
+			c.push(fmt.Sprintf("slice[%d]", i))
+			if i < aLen && i < bLen {
+				c.equals(a.Index(i), b.Index(i), level+1)
+			} else if i < aLen {
+				c.saveDiff(a.Index(i), "<no value>")
+			} else {
+				c.saveDiff("<no value>", b.Index(i))
+			}
+			c.pop()
+			if len(c.diff) >= MaxDiff {
+				break
+			}
+		}
+
+	/////////////////////////////////////////////////////////////////////
+	// Primitive kinds
+	/////////////////////////////////////////////////////////////////////
+
+	case reflect.Float32, reflect.Float64:
+		// Avoid 0.04147685731961082 != 0.041476857319611
+		// 6 decimal places is close enough
+		aval := fmt.Sprintf(c.floatFormat, a.Float())
+		bval := fmt.Sprintf(c.floatFormat, b.Float())
+		if aval != bval {
+			c.saveDiff(a.Float(), b.Float())
+		}
+	case reflect.Bool:
+		if a.Bool() != b.Bool() {
+			c.saveDiff(a.Bool(), b.Bool())
+		}
+	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
+		if a.Int() != b.Int() {
+			c.saveDiff(a.Int(), b.Int())
+		}
+	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
+		if a.Uint() != b.Uint() {
+			c.saveDiff(a.Uint(), b.Uint())
+		}
+	case reflect.String:
+		if a.String() != b.String() {
+			c.saveDiff(a.String(), b.String())
+		}
+
+	default:
+		logError(ErrNotHandled)
+	}
+}
+
+func (c *cmp) push(name string) {
+	c.buff = append(c.buff, name)
+}
+
+func (c *cmp) pop() {
+	if len(c.buff) > 0 {
+		c.buff = c.buff[0 : len(c.buff)-1]
+	}
+}
+
+func (c *cmp) saveDiff(aval, bval interface{}) {
+	if len(c.buff) > 0 {
+		varName := strings.Join(c.buff, ".")
+		c.diff = append(c.diff, fmt.Sprintf("%s: %v != %v", varName, aval, bval))
+	} else {
+		c.diff = append(c.diff, fmt.Sprintf("%v != %v", aval, bval))
+	}
+}
+
+func init() {
+	log.SetFlags(log.Lshortfile)
+}
+
+func logError(err error) {
+	if LogErrors {
+		log.Println(err)
+	}
+}
--- /dev/null
+++ b/deep/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright 2015-2017 Daniel Nichter
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
--- /dev/null
+++ b/deep/deep_test.go
@@ -0,0 +1,714 @@
+package deep_test
+
+import (
+	"errors"
+	"testing"
+	"time"
+
+	"github.com/go-test/deep"
+)
+
+func TestString(t *testing.T) {
+	diff := deep.Equal("foo", "foo")
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	diff = deep.Equal("foo", "bar")
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "foo != bar" {
+		t.Error("wrong diff:", diff[0])
+	}
+}
+
+func TestFloat(t *testing.T) {
+	diff := deep.Equal(1.1, 1.1)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	diff = deep.Equal(1.1234561, 1.1234562)
+	if diff == nil {
+		t.Error("no diff")
+	}
+
+	defaultFloatPrecision := deep.FloatPrecision
+	deep.FloatPrecision = 6
+	defer func() { deep.FloatPrecision = defaultFloatPrecision }()
+
+	diff = deep.Equal(1.1234561, 1.1234562)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	diff = deep.Equal(1.123456, 1.123457)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "1.123456 != 1.123457" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+}
+
+func TestInt(t *testing.T) {
+	diff := deep.Equal(1, 1)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	diff = deep.Equal(1, 2)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "1 != 2" {
+		t.Error("wrong diff:", diff[0])
+	}
+}
+
+func TestUint(t *testing.T) {
+	diff := deep.Equal(uint(2), uint(2))
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	diff = deep.Equal(uint(2), uint(3))
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "2 != 3" {
+		t.Error("wrong diff:", diff[0])
+	}
+}
+
+func TestBool(t *testing.T) {
+	diff := deep.Equal(true, true)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	diff = deep.Equal(false, false)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	diff = deep.Equal(true, false)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "true != false" { // unless you're fipar
+		t.Error("wrong diff:", diff[0])
+	}
+}
+
+func TestTypeMismatch(t *testing.T) {
+	type T1 int // same type kind (int)
+	type T2 int // but different type
+	var t1 T1 = 1
+	var t2 T2 = 1
+	diff := deep.Equal(t1, t2)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "deep_test.T1 != deep_test.T2" {
+		t.Error("wrong diff:", diff[0])
+	}
+}
+
+func TestKindMismatch(t *testing.T) {
+	deep.LogErrors = true
+
+	var x int = 100
+	var y float64 = 100
+	diff := deep.Equal(x, y)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "int != float64" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+	deep.LogErrors = false
+}
+
+func TestDeepRecursion(t *testing.T) {
+	deep.MaxDepth = 2
+	defer func() { deep.MaxDepth = 10 }()
+
+	type s3 struct {
+		S int
+	}
+	type s2 struct {
+		S s3
+	}
+	type s1 struct {
+		S s2
+	}
+	foo := map[string]s1{
+		"foo": { // 1
+			S: s2{ // 2
+				S: s3{ // 3
+					S: 42, // 4
+				},
+			},
+		},
+	}
+	bar := map[string]s1{
+		"foo": {
+			S: s2{
+				S: s3{
+					S: 100,
+				},
+			},
+		},
+	}
+	diff := deep.Equal(foo, bar)
+
+	defaultMaxDepth := deep.MaxDepth
+	deep.MaxDepth = 4
+	defer func() { deep.MaxDepth = defaultMaxDepth }()
+
+	diff = deep.Equal(foo, bar)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "map[foo].S.S.S: 42 != 100" {
+		t.Error("wrong diff:", diff[0])
+	}
+}
+
+func TestMaxDiff(t *testing.T) {
+	a := []int{1, 2, 3, 4, 5, 6, 7}
+	b := []int{0, 0, 0, 0, 0, 0, 0}
+
+	defaultMaxDiff := deep.MaxDiff
+	deep.MaxDiff = 3
+	defer func() { deep.MaxDiff = defaultMaxDiff }()
+
+	diff := deep.Equal(a, b)
+	if diff == nil {
+		t.Fatal("no diffs")
+	}
+	if len(diff) != deep.MaxDiff {
+		t.Errorf("got %d diffs, execpted %d", len(diff), deep.MaxDiff)
+	}
+
+	defaultCompareUnexportedFields := deep.CompareUnexportedFields
+	deep.CompareUnexportedFields = true
+	defer func() { deep.CompareUnexportedFields = defaultCompareUnexportedFields }()
+	type fiveFields struct {
+		a int // unexported fields require ^
+		b int
+		c int
+		d int
+		e int
+	}
+	t1 := fiveFields{1, 2, 3, 4, 5}
+	t2 := fiveFields{0, 0, 0, 0, 0}
+	diff = deep.Equal(t1, t2)
+	if diff == nil {
+		t.Fatal("no diffs")
+	}
+	if len(diff) != deep.MaxDiff {
+		t.Errorf("got %d diffs, execpted %d", len(diff), deep.MaxDiff)
+	}
+
+	// Same keys, too many diffs
+	m1 := map[int]int{
+		1: 1,
+		2: 2,
+		3: 3,
+		4: 4,
+		5: 5,
+	}
+	m2 := map[int]int{
+		1: 0,
+		2: 0,
+		3: 0,
+		4: 0,
+		5: 0,
+	}
+	diff = deep.Equal(m1, m2)
+	if diff == nil {
+		t.Fatal("no diffs")
+	}
+	if len(diff) != deep.MaxDiff {
+		t.Log(diff)
+		t.Errorf("got %d diffs, execpted %d", len(diff), deep.MaxDiff)
+	}
+
+	// Too many missing keys
+	m1 = map[int]int{
+		1: 1,
+		2: 2,
+	}
+	m2 = map[int]int{
+		1: 1,
+		2: 2,
+		3: 0,
+		4: 0,
+		5: 0,
+		6: 0,
+		7: 0,
+	}
+	diff = deep.Equal(m1, m2)
+	if diff == nil {
+		t.Fatal("no diffs")
+	}
+	if len(diff) != deep.MaxDiff {
+		t.Log(diff)
+		t.Errorf("got %d diffs, execpted %d", len(diff), deep.MaxDiff)
+	}
+}
+
+func TestNotHandled(t *testing.T) {
+	a := func(int) {}
+	b := func(int) {}
+	diff := deep.Equal(a, b)
+	if len(diff) > 0 {
+		t.Error("got diffs:", diff)
+	}
+}
+
+func TestStruct(t *testing.T) {
+	type s1 struct {
+		id     int
+		Name   string
+		Number int
+	}
+	sa := s1{
+		id:     1,
+		Name:   "foo",
+		Number: 2,
+	}
+	sb := sa
+	diff := deep.Equal(sa, sb)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	sb.Name = "bar"
+	diff = deep.Equal(sa, sb)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "Name: foo != bar" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+	sb.Number = 22
+	diff = deep.Equal(sa, sb)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 2 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "Name: foo != bar" {
+		t.Error("wrong diff:", diff[0])
+	}
+	if diff[1] != "Number: 2 != 22" {
+		t.Error("wrong diff:", diff[1])
+	}
+
+	sb.id = 11
+	diff = deep.Equal(sa, sb)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 2 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "Name: foo != bar" {
+		t.Error("wrong diff:", diff[0])
+	}
+	if diff[1] != "Number: 2 != 22" {
+		t.Error("wrong diff:", diff[1])
+	}
+}
+
+func TestNestedStruct(t *testing.T) {
+	type s2 struct {
+		Nickname string
+	}
+	type s1 struct {
+		Name  string
+		Alias s2
+	}
+	sa := s1{
+		Name:  "Robert",
+		Alias: s2{Nickname: "Bob"},
+	}
+	sb := sa
+	diff := deep.Equal(sa, sb)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	sb.Alias.Nickname = "Bobby"
+	diff = deep.Equal(sa, sb)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "Alias.Nickname: Bob != Bobby" {
+		t.Error("wrong diff:", diff[0])
+	}
+}
+
+func TestMap(t *testing.T) {
+	ma := map[string]int{
+		"foo": 1,
+		"bar": 2,
+	}
+	mb := map[string]int{
+		"foo": 1,
+		"bar": 2,
+	}
+	diff := deep.Equal(ma, mb)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	diff = deep.Equal(ma, ma)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	mb["foo"] = 111
+	diff = deep.Equal(ma, mb)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "map[foo]: 1 != 111" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+	delete(mb, "foo")
+	diff = deep.Equal(ma, mb)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "map[foo]: 1 != <does not have key>" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+	diff = deep.Equal(mb, ma)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "map[foo]: <does not have key> != 1" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+	var mc map[string]int
+	diff = deep.Equal(ma, mc)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	// handle hash order randomness
+	if diff[0] != "map[foo:1 bar:2] != <nil map>" && diff[0] != "map[bar:2 foo:1] != <nil map>" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+	diff = deep.Equal(mc, ma)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "<nil map> != map[foo:1 bar:2]" && diff[0] != "<nil map> != map[bar:2 foo:1]" {
+		t.Error("wrong diff:", diff[0])
+	}
+}
+
+func TestSlice(t *testing.T) {
+	a := []int{1, 2, 3}
+	b := []int{1, 2, 3}
+
+	diff := deep.Equal(a, b)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	diff = deep.Equal(a, a)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	b[2] = 333
+	diff = deep.Equal(a, b)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "slice[2]: 3 != 333" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+	b = b[0:2]
+	diff = deep.Equal(a, b)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "slice[2]: 3 != <no value>" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+	diff = deep.Equal(b, a)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "slice[2]: <no value> != 3" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+	var c []int
+	diff = deep.Equal(a, c)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "[1 2 3] != <nil slice>" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+	diff = deep.Equal(c, a)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "<nil slice> != [1 2 3]" {
+		t.Error("wrong diff:", diff[0])
+	}
+}
+
+func TestPointer(t *testing.T) {
+	type T struct {
+		i int
+	}
+	a := &T{i: 1}
+	b := &T{i: 1}
+	diff := deep.Equal(a, b)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+
+	a = nil
+	diff = deep.Equal(a, b)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "<nil pointer> != deep_test.T" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+	a = b
+	b = nil
+	diff = deep.Equal(a, b)
+	if diff == nil {
+		t.Fatal("no diff")
+	}
+	if len(diff) != 1 {
+		t.Error("too many diff:", diff)
+	}
+	if diff[0] != "deep_test.T != <nil pointer>" {
+		t.Error("wrong diff:", diff[0])
+	}
+
+	a = nil
+	b = nil
+	diff = deep.Equal(a, b)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+}
+
+func TestTime(t *testing.T) {
+	// In an interable kind (i.e. a struct)
+	type sTime struct {
+		T time.Time
+	}
+	now := time.Now()
+	got := sTime{T: now}
+	expect := sTime{T: now.Add(1 * time.Second)}
+	diff := deep.Equal(got, expect)
+	if len(diff) != 1 {
+		t.Error("expected 1 diff:", diff)
+	}
+
+	// Directly
+	a := now
+	b := now
+	diff = deep.Equal(a, b)
+	if len(diff) > 0 {
+		t.Error("should be equal:", diff)
+	}
+}
+
+func TestInterface(t *testing.T) {
+	a := map[string]interface{}{
+		"foo": map[string]string{
+			"bar": "a",
+		},
+	}
+	b := map[string]interface{}{
+		"foo": map[string]string{
+			"bar": "b",
+		},
+	}
+	diff := deep.Equal(a, b)
+	if len(diff) == 0 {
+		t.Fatalf("expected 1 diff, got zero")
+	}
+	if len(diff) != 1 {
+		t.Errorf("expected 1 diff, got %d", len(diff))
+	}
+}
+
+func TestError(t *testing.T) {
+	a := errors.New("it broke")
+	b := errors.New("it broke")
+
+	diff := deep.Equal(a, b)
+	if len(diff) != 0 {
+		t.Fatalf("expected zero diffs, got %d: %s", len(diff), diff)
+	}
+
+	b = errors.New("it fell apart")
+	diff = deep.Equal(a, b)
+	if len(diff) != 1 {
+		t.Fatalf("expected 1 diff, got %d", len(diff))
+	}
+	if diff[0] != "it broke != it fell apart" {
+		t.Errorf("got '%s', expected 'it broke != it fell apart'", diff[0])
+	}
+
+	// Both errors set
+	type tWithError struct {
+		Error error
+	}
+	t1 := tWithError{
+		Error: a,
+	}
+	t2 := tWithError{
+		Error: b,
+	}
+	diff = deep.Equal(t1, t2)
+	if len(diff) != 1 {
+		t.Fatalf("expected 1 diff, got %d", len(diff))
+	}
+	if diff[0] != "Error: it broke != it fell apart" {
+		t.Errorf("got '%s', expected 'Error: it broke != it fell apart'", diff[0])
+	}
+
+	// Both errors nil
+	t1 = tWithError{
+		Error: nil,
+	}
+	t2 = tWithError{
+		Error: nil,
+	}
+	diff = deep.Equal(t1, t2)
+	if len(diff) != 0 {
+		t.Log(diff)
+		t.Fatalf("expected 0 diff, got %d", len(diff))
+	}
+
+	// One error is nil
+	t1 = tWithError{
+		Error: errors.New("foo"),
+	}
+	t2 = tWithError{
+		Error: nil,
+	}
+	diff = deep.Equal(t1, t2)
+	if len(diff) != 1 {
+		t.Log(diff)
+		t.Fatalf("expected 1 diff, got %d", len(diff))
+	}
+	if diff[0] != "Error: *errors.errorString != <nil pointer>" {
+		t.Errorf("got '%s', expected 'Error: *errors.errorString != <nil pointer>'", diff[0])
+	}
+}
+
+func TestNil(t *testing.T) {
+	type student struct {
+		name string
+		age  int
+	}
+
+	mark := student{"mark", 10}
+	var someNilThing interface{} = nil
+	diff := deep.Equal(someNilThing, mark)
+	if diff == nil {
+		t.Error("Nil value to comparision should not be equal")
+	}
+	diff = deep.Equal(mark, someNilThing)
+	if diff == nil {
+		t.Error("Nil value to comparision should not be equal")
+	}
+	diff = deep.Equal(someNilThing, someNilThing)
+	if diff != nil {
+		t.Error("Nil value to comparision should not be equal")
+	}
+}
